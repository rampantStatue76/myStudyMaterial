## 为什么需要nextTick
在 Vue 的响应式系统里，当修改数据（如 this.someData = ... 或者 ref.value = ...），Vue 并不会立刻同步更新 DOM。它会做一个批量更新的优化：把多个数据变更合并，然后在下一个“tick”时统一进行 DOM 更新。这样可以减少多次不必要的重绘 / 重排，提高性能。
但正因为 DOM 更新是异步的，所以如果你紧接着就去读取 DOM，比如 this.$refs.el.clientHeight，此时 DOM 还没更新，读到的可能是旧值。为了解决这种“先改数据、后操作 DOM，但 DOM 必须是最新”的场景，就使用 nextTick。

Vue 是响应式的。当你修改数据（state / reactive / ref / props 等），Vue 不会立刻把 DOM 更新同步地反映出来，而是把这些变更 异步批量处理，在下一个“tick”里统一更新 DOM。 
所以，如果你在修改数据之后立刻去读取 DOM（比如 this.$refs.el.clientHeight、getBoundingClientRect() 等），这时 DOM 很可能还没更新，读到的是旧值。
nextTick 的作用是：把你的回调延迟到 DOM 更新完成之后 再执行，这样你就能安全地操作、读取更新后的 DOM。

### 例子
```vue

<template>
  <div>
    <button @click="addItem">添加一项</button>
    <div ref="listContainer" style="max-height: 100px; overflow: auto; border: 1px solid #ccc;">
      <div v-for="(item, idx) in list" :key="idx">
        {{ item }}
      </div>
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      list: []
    };
  },
  methods: {
    addItem() {
      // 先修改响应式数据
      this.list.push("第 " + (this.list.length + 1) + " 项");

      // 等 DOM 更新完成后再做某些操作（比如滚动到最底部）
      this.$nextTick(() => {
        const container = this.$refs.listContainer;
        if (container) {
          container.scrollTop = container.scrollHeight;
        }
      });
    }
  }
};
</script>

<style>
/* 样式略 */
</style>

```

```vue
<template>
  <div>
    <button @click="addItem">添加一项</button>
    <div ref="listContainer" style="max-height: 100px; overflow: auto; border: 1px solid #ccc;">
      <div v-for="(item, idx) in list" :key="idx">
        {{ item }}
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, nextTick } from 'vue';

const list = ref([]);
const listContainer = ref(null);

function addItem() {
  list.value.push("第 " + (list.value.length + 1) + " 项");

  // 等 DOM 更新完成后再做操作
  nextTick(() => {
    const container = listContainer.value;
    if (container) {
      container.scrollTop = container.scrollHeight;
    }
  });
}
</script>

<style>
/* 样式略 */
</style>

```