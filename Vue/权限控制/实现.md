## 基本流程
- 写一个useUserStore用来存储用户信息，在此store中有fetchUserPermissions方法：
    ```javascript
    // actions里面
    async fetchUserPermissions() {
      const res = await api.get('/user/permissions'); // 后端接口
      this.userId = res.userId;
      this.role = res.role;
      this.permissions = res.permissions; 
      this.routes = res.routes; // 后端返回的权限数组，有不同路由权限信息
    },
    hasPermission(perm: string) {  // 检查是否有权限
      return this.permissions.includes(perm);
    },
    hasRole(role: string) {
      return this.roles.includes(role);
    }
    ```
- 在router/index.js中：
    ```javascript
    // 在 main.js 或 App.vue 初始化时，调用 setupDynamicRoutes() 在用户登录后注入权限路由。
    export async function setupDynamicRoutes() {
      const userStore = useUserStore();
      await userStore.fetchUserPermissions(); // 建立权限表

      const userRoutes = userStore.routes.map(r => ({
        path: r.path,
        name: r.name,
        component: () => import(`@/views/${r.component}.vue`),
        meta: r.meta
      }));

      userRoutes.forEach(r => {
        router.addRoute(r);
      });
    }
    // 路由守卫用于控制页面访问权限
    router.beforeEach((to, from, next) => {
      const userStore = useUserStore();
      const { role, token } = userStore;
        // 如果路由需要角色且用户未登录
        if (to.meta.roles && !token) {
          return next({ name: 'Unauthorized' });
        }
        if (to.meta.roles && !to.meta.roles.includes(role)) {
          return next({ name: 'Unauthorized' });
        }
        return next();
    });
    ```
- 指令封装 directive
  ```javascript
  // src/directives/permission.js
  import { useUserStore } from '@/stores/user';

  export default {
    beforeMount(el, binding) {
      const userStore = useUserStore();

      // 获取指令绑定的值：
      // 支持两种形式：字符串权限，或对象 { permission: "...", role: "..." }
      let requiredPerm = null;
      let requiredRole = null;

      if (typeof binding.value === 'string') {
        requiredPerm = binding.value;
      } else if (binding.value && typeof binding.value === 'object') {
        requiredPerm = binding.value.permission || null;
        requiredRole = binding.value.role || null;
      }

      // 判断是否用了 .disable 修饰符：如果用了，则「禁用」代替「隐藏」
      const disableInsteadOfHide = !!binding.modifiers.disable;

      // 检查权限与角色
      let hasAuth = true;
      if (requiredPerm) {
        hasAuth = userStore.hasPermission(requiredPerm);
      }
      if (hasAuth && requiredRole) {
        hasAuth = userStore.hasRole(requiredRole);
      }

      if (!hasAuth) {
        if (disableInsteadOfHide) {
          // 禁用元素
          el.setAttribute('disabled', 'true');
          el.style.pointerEvents = 'none';
          el.style.opacity = '0.6';
        } else {
          // 隐藏元素
          el.style.display = 'none';
        }
      }
    }
  };
  ```
### 后端返回数据格式
```javascript
{
  "userId": "123",
  "role": "editor",
  "permissions": ["post:create", "post:edit", "dashboard:view"],
  "routes": [
    { "path": "/dashboard", "name": "Dashboard", "component": "DashboardView", "meta": { "title": "Dashboard" } },
    { "path": "/posts", "name": "Posts", "component": "PostsView", "meta": { "title": "Posts", "permission": "post:view" ,"role":[写可以访问该页面的角色有哪些]} },
    { "path": "/posts/edit/:id", "name": "PostEdit", "component": "PostEditView", "meta": { "title": "Edit Post", "permission": "post:edit" } }
  ]
}
```

## 总结
- 在useUserStore中有fetchUserPermissions方法（用于获取当前用户权限路由数组routes和权限数组permissions和当前用户的角色role）
- 在router/index.js中：
  1.有setupDynamicRoutes方法：调用userStore为并使用router.add()方法为当前路由添加路由记录,路由记录中的meta配置项用于存放此路由记录的权限
  2.使用路由守卫控制用户的路由访问权限：router.beforeEach((to,from,next)=>{
    const { role } = useUserStore()
    if(to.meta.roles && to.meta.roles.includes(role)){
      return next({ name: 'Unauthorized' });
    }
  })
- 自定义指令