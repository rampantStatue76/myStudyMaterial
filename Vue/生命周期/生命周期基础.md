# vue2 
beforeCreate
created         ===> 单组件请求
beforeMount
mounted         ===> 获取dom节点，如果先子组件请求后父组件请求
boforeUpdate
updated
beforeDestroy
destroyed       ===> 关闭页面的时候记录视频的播放进度
activated       ===> 判断id是否相等，不相等则发起请求
deactivated

### 一进入组件就会执行前四个生命周期组件：
beforeCreate：准备数据
created：数据准备完成，可以获取data、methods、computed、watch
beforeMount：准备挂载节点
mounted：挂载完成，有dom节点

### 父组件中引入子组件，生命周期的执行顺序是：
现执行父的beforeCreate\created\beforeMount(把父数据准备好)，再执行子的beforeCreate\created\beforeMount\mounted(把子的dom节点挂载到父的dom节点中完毕)后，在执行父的mounted

### 为什么一般不把发起请求放在beforeCreate中？
因为发起请求的函数是异步的，所以理论在不管是在beforeCreate中发起请求还是在其他地方发起请求都可以（因为在js中先执行同步任务再执行异步任务），但是我们一般会将请求在methods中封装好，使用beforeCreate的时候是不可以获取到这个methods的，就不能正常调用这个函数以发起请求


### 发送请求应该放在created中还是mounted中呢？
这个要根据具体业务来决定了，如果在一个页面中我们想要先渲染子组建的内容，后渲染父组件的内容的话，那我们就应该把父组件的数据请求放在mounted中，因为在父组件中引入了子组件后，父子组件的生命周期是先执行父组件的前三个生命周期，再执行子组件的前四个生命周期，所以此时将子组件的请求放在created中，父组件的请求放在mounted中，就可以保证在父组件中是先渲染子组件的，再渲染父组件的

# Vue3

onBeforeMounted

onMouted

onBoforeUpdated

onUpdated

onBeforeUnMounted

onUnmounted

onReactivated

onDeactivated