### 大体流程

需要初始化的数据有，在onMounted中执行，这些值如果在localStorage中能找到就其初始化为localStorage中的值：initSessionList \ initIndex (初始化activeIndex和queryInfos) \ initModel (初始模型) \ initTokens (获取余额)

- queryInfos储存右侧显示的对话，包括{message:[], model:'', MODEL_CONFIG}，用一个watch监听queryInfos.model的变化，有变化则存入localStorage。

- sessionList储存全部对话信息，initSessionList初始化seesionList，准备一个watch监听seesionList变化，有变化则更改localStorage存储seesionList的值，sessionList里面存的是一个个对象，包括title、createTime、message:[] 等属性，记录对话的基础信息

- queryKeys是user聊天框的关键字

- 点击左侧不同会话，切换activeIndex和queryInfos的值

- 诊断Gemini API连接，验证API_CONFIG的apiKey是否存在且以AIza开头还有baseURL是否包含某个字段，MODEL_CONFIG配置是否正确

- const scrollBottom = () => {

   nextTick(() => {

    const div = document.getElementById("messageCompBox");

    div.scrollTop = div.scrollHeight - div.clientHeight;

   });

  };

- deepseek：token就是apiKey

- 消息发出后的处理：往当前queryInfos.value.message中添加一条数据,{role: 'user', content: queryKeys.value}后滑动到底部；
  根据会话类型获得系统提示词systemPrompt，根据systemPrompt和queryInfos.value.message.slice(0, -1)拼接为messagesWithSystemPrompt，
   ```javascript
   const messagesWithSystemPrompt = [
        {
          role: 'system',
          content: systemPrompt
        },
        // 包含所有用户消息，但不包含最后一条空的assistant消息
        ...queryInfos.value.messages.slice(0, -1)
      ];
   ```
  最后形成
  ```javascript
  const requestConfig = {
        ...queryInfos.value,
        messages: messagesWithSystemPrompt,
        stream: true // 启用流式响应
      };
   ```
   使用requestConfig发送请求，const response = await openai.value.chat.completions.create(requestConfig);
   ```javascript
   // 实现流式输出的核心： 
   // 当 stream: true 配置启用时，API 返回的 response 对象实现了异步可迭代协议（Async Iterable Protocol），这意味着：
   // 可以通过 for await...of 语法来消费数据
   for await (const part of response) {
      queryInfos.value.messages[queryInfos.value.messages.length - 1].content += part.choices[0].delta.content;
   }
   ```