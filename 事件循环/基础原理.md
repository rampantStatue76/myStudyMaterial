## 事件循环原理
1.js是单线程的，同时只能运行一个任务，上一个任务执行完才能执行下一个任务，但是有些任务是需要消耗时间的，如果遇到消耗时间比较多的任务，会造成任务阻塞，运行效率太低了，所以为了避免任务阻塞，我们将任务分为同步任务和异步任务（同步任务就是立即执行的任务，异步任务就是需要消耗时间的任务）
2.js引擎执行同步任务，异步任务交给宿主环境执行（WebApi、浏览器）
3.遇见同步任务放进执行栈，异步任务等待时机成熟送入任务队列排队执行（任务队列分为宏任务队列、微任务队列，先执行微任务队列，再执行宏任务队列）
4.执行栈执行完毕后，去任务队列看是否有任务，有就送入执行栈执行，反复循环查看执行，这个过程就是事件循环

### 宏任务和微任务
#### 宏任务是由宿主环境（浏览器、node）发起的：
    1.script（整体代码） 
    2.setTimeout/setInterval/setImmediate 
    3.网络请求（Ajax、Fetch）
#### 微任务是是js引擎发起的任务：
    1.Promise.then/.catch/.finally（注意：Promise本身是同步的，then、catch的回调函数才是异步的）
    2.MutationObserver
    4.Async/Await（在async函数中执行的代码）

### 笔试题
```javascript
console.log(1)
setTimeout(() => {
    console.log(2)
    let p =new Promise((resoleve) => {
        resoleve(3)
    })
    new Promise((resolve)=>{
        resolve(4)
    }).then((data)=> console.log(data) )
    p.then((data) => console.log(data))
    console.log(5)
})
console.log(6)
//输出 1 6 2 5 4 3
```
```javascript
// 2 3 6 p2 p1 1 4 5
setTimeout(() => {
    console.log(1)
},0)
new Promise((resolve) => {
    console.log(2)
    resolve('p1')

    new Promise((resolve) => {
        console.log(3)
        setTimeout(() => {
            resolve('setTimeout2')
            console.log(4)
        })
        resolve('p2')
    }).then((res) => console.log(res))

    setTimeout(()=>{
        console.log(5)
    })
}).then((res) => console.log(res))
console.log(6)
```
```javascript
async function async1(){
    console.log('async1 start')
    await async2()   // await会右结合：（await等待后面的任务完成后就把接下来的代码推入微队列）
    console.log('async1 end')
}
async function async2(){
    console.log('async2')
}

console.log('script start')

setTimeout(function(){
    console.log('setTimeout')
},0)

async1()

// script start 
// async1 start
// async2
// async1 end
// setTimeout
```