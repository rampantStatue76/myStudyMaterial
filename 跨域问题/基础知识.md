## 跨域问题的基本概念
浏览器出于安全考虑，设计了同源策略：对 同源请求 放行，对 异源 请求限制（同源：协议、域名、端口号相同）。浏览器对元素标签发出的跨域请求轻微限制，对ajax发出的跨域请求限制比较严厉。

![ajax跨域](C:\Users\SF\Desktop\学习文档\跨域问题\ajax跨域.png)

### 解决跨域问题
- CORS(cross-origin resource sharing)
  在服务器上设置：
    简单请求：res.setHeader('Access-Control-Allow-Origin', '*');
    预检请求：res.setHeader("Access-Control-Allow-Methods", "GET, PUT, OPTIONS, POST");
![CORS](C:\Users\SF\Desktop\学习文档\跨域问题\CORS.png)

- JSONP
  利用的原理是script标签可以跨域请求资源，将回调函数作为参数拼接在url中。后端收到请求，调用该回调函数，并将数据作为参数返回去，注意设置响应头返回文档类型，应该设置成javascript。
  缺点： 只能通过在url上带callback回调函数的方式用<script>标签请求资源，也就是只能发送get请求
  ```javascript
  // 前端
  function handleData(data) {
      console.log('收到 data:', data);
      const div = document.getElementById('output');
      div.innerText = `message: ${data.message}\n时间: ${data.time}`;
    }
  script.src = 'http://localhost:4000/getData?callback=handleData';
  // 后端
  // server.js
  const express = require('express');
  const app = express();

  app.get('/getData', (req, res) => {
    const callbackName = req.query.callback;  // 客户端指定的 callback 函数名
    const data = {
      message: 'Hello from JSONP server',
      time: new Date().toISOString()
    };

    // 如果没有 callback 参数，就可以返回普通 JSON（视需求），但这里我们做 JSONP
    if (callbackName) {
      // 响应要包装成 callback(data)
      const json = JSON.stringify(data);
      const responseText = `${callbackName}(${json});`;

      // 设置 Content-Type 为 JavaScript
      res.set('Content-Type', 'application/javascript');
      res.send(responseText);
    } else {
      // fallback: 普通 JSON
      res.json(data);
    }
  });

  const port = 4000;
  app.listen(port, () => {
    console.log(`JSONP server listening at http://localhost:${port}`);
  });

  ```

- 代理服务器
  原理是服务器之间是没有同源策略的，浏览器向代理服务器发起请求，再由代理服务器向目标服务器发起请求，返回给浏览器。